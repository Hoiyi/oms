package com.hu.sysManagement.system.service.impl;import com.hu.operation.duty.dao.DutyOrderMapper;import com.hu.operation.duty.domain.DutyOrder;import com.hu.sysManagement.common.config.Constant;import com.hu.sysManagement.common.dao.DistrictDao;import com.hu.sysManagement.common.domain.Tree;import com.hu.sysManagement.common.utils.BeanMapConvertUtil;import com.hu.sysManagement.common.utils.BuildTree;import com.hu.sysManagement.common.utils.MD5Utils;import com.hu.sysManagement.common.utils.Result;import com.hu.sysManagement.system.dao.DataPermDao;import com.hu.sysManagement.system.dao.DeptDao;import com.hu.sysManagement.system.dao.UserDao;import com.hu.sysManagement.system.dao.UserRoleDao;import com.hu.sysManagement.system.domain.DataPerm;import com.hu.sysManagement.system.domain.Dept;import com.hu.sysManagement.system.domain.User;import com.hu.sysManagement.system.domain.UserRole;import com.hu.sysManagement.system.domain.UserUpdate;import com.hu.sysManagement.system.service.UserService;import java.util.ArrayList;import java.util.Arrays;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Objects;import java.util.Set;import org.apache.commons.lang.ArrayUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Transactional@Servicepublic class UserServiceImpl        implements UserService {    @Autowired    UserDao userMapper;    @Autowired    UserRoleDao userRoleMapper;    @Autowired    DeptDao deptMapper;    @Autowired    DataPermDao dataPermDao;    @Autowired    DutyOrderMapper dutyOrderMapper;    @Autowired    DistrictDao districtDao;    private static final Logger logger = LoggerFactory.getLogger(UserService.class);    private BeanMapConvertUtil<User> convertUtil = new BeanMapConvertUtil<User>(User.class);    @Override    public User get(Long id) {        List<Long> roleIds = userRoleMapper.listRoleId(id);        User user = userMapper.get(id);        user.setDeptName(deptMapper.get(user.getDeptId()).getName());        user.setRoleIds(roleIds);        user.setDataPerms(dataPermDao.listPermId(id));        return user;    }    @Override    public List<Map<String, Object>> list(Map<String, Object> map) {        return userMapper.list(map);    }    @Override    public List<User> userList(Map<String, Object> map) {        return convertUtil.convert(userMapper.list(map));    }    @Override    public int count(Map<String, Object> map) {        return userMapper.count(map);    }    @Transactional    @Override    public int save(User user) {        int count = userMapper.save(user);        List<Long> dataPerms = user.getDataPerms();        List<DataPerm> dataPermList = new ArrayList<DataPerm>();        if (user.getDataPerms() != null) {            for (Long userId : dataPerms) {                DataPerm dataPerm = new DataPerm();                dataPerm.setUserId(user.getUserId());                dataPerm.setPermsUserId(userId);                dataPermList.add(dataPerm);            }        }        if (dataPermList.size() > 0) {            dataPermDao.batchSave(dataPermList);        }        Long userId = user.getUserId();        List<Long> roles = user.getRoleIds();        userRoleMapper.removeByUserId(userId);        List<UserRole> list = new ArrayList<UserRole>();        for (Long roleId : roles) {            UserRole ur = new UserRole();            ur.setUserId(userId);            ur.setRoleId(roleId);            list.add(ur);        }        if (list.size() > 0) {            userRoleMapper.batchSave(list);        }        return count;    }    @Override    public int update(User user) {        user.setPassword(MD5Utils.encrypt(user.getUsername(), Constant.defaultPassword));        int r = userMapper.updatePj(user);        dataPermDao.removeByUserId(user.getUserId());        List<Long> dataPerms = user.getDataPerms();        List dataPermList = new ArrayList();        if (user.getDataPerms() != null) {            for (Long userId : dataPerms) {                DataPerm dataPerm = new DataPerm();                dataPerm.setUserId(user.getUserId());                dataPerm.setPermsUserId(userId);                dataPermList.add(dataPerm);            }        }        if (dataPermList.size() > 0) {            dataPermDao.batchSave(dataPermList);        }        Long userId = user.getUserId();        List<Long> roles = user.getRoleIds();        userRoleMapper.removeByUserId(userId);        List list = new ArrayList();        for (Long roleId : roles) {            UserRole ur = new UserRole();            ur.setUserId(userId);            ur.setRoleId(roleId);            list.add(ur);        }        if (list.size() > 0) {            userRoleMapper.batchSave(list);        }        return r;    }    @Override    public Result remove(Long userId) {        Map params = new HashMap(1);        params.put("principalId", new Long[]{userId});        if (districtDao.count(params) > 0) {            return Result.error("此用户为片区负责人，请解除绑定后操作！");        }        List<DutyOrder> orders = dutyOrderMapper.selectByExample(null);        for (DutyOrder dutyOrder : orders) {            if ((StringUtils.isNotBlank(dutyOrder.getNameOrder())) &&                    (Arrays.asList(dutyOrder.getNameOrder().split(",")).contains(String.valueOf(userId)))) {                return Result.error("请先到值班管理移除此用户");            }        }        userRoleMapper.removeByUserId(userId);        if (userMapper.remove(userId) > 0) {            return Result.ok();        }        return Result.error();    }    @Override    public Set<String> listRoles(Long userId) {        return null;    }    @Override    public int resetPwd(UserUpdate userUpdate, User user) throws Exception {        if (Objects.equals(userUpdate.getUser().getUserId(), user.getUserId())) {            if (Objects.equals(MD5Utils.encrypt(user.getUsername(), userUpdate.getPwdOld()), user.getPassword())) {                user.setPassword(MD5Utils.encrypt(user.getUsername(), userUpdate.getPwdNew()));                user.setGmtModified(new Date());                return userMapper.updatePj(user);            }            throw new Exception("输入的旧密码有误！");        }        throw new Exception("修改的不是你登录的账号！");    }    @Override    public int adminResetPwd(Long id)            throws Exception {        User user = get(id);        user.setGmtModified(new Date());        user.setPassword(MD5Utils.encrypt(user.getUsername(), Constant.defaultPassword));        return userMapper.updatePj(user);    }    @Transactional    @Override    public int batchremove(Long[] userIds) {        int count = userMapper.batchRemove(userIds);        userRoleMapper.batchRemoveByUserId(userIds);        return count;    }    @Override    public Tree<Dept> getTree() {        List trees = new ArrayList();        List<Dept> depts = deptMapper.list(new HashMap(16));        Long[] pDepts = deptMapper.listParentDept();        Long[] uDepts = userMapper.listAllDept();        Long[] allDepts = (Long[]) ArrayUtils.addAll(pDepts, uDepts);        Tree tree;        for (Dept dept : depts) {            if (ArrayUtils.contains(allDepts, dept.getDeptId())) {                tree = new Tree();                tree.setId(dept.getDeptId().toString());                tree.setParentId(dept.getParentId().toString());                tree.setText(dept.getName());                Map state = new HashMap(16);                state.put("opened", Boolean.valueOf(true));                state.put("mType", "dept");                tree.setState(state);                trees.add(tree);            }        }        List<User> users = userList(new HashMap());        for (User user : users) {            Tree tree2 = new Tree();            tree2.setId(user.getUserId().toString());            tree2.setParentId(user.getDeptId().toString());            tree2.setText(user.getName());            Map state = new HashMap(16);            state.put("opened", Boolean.valueOf(true));            state.put("mType", "user");            tree2.setState(state);            trees.add(tree2);        }        Tree t = BuildTree.build(trees);        return t;    }    @Override    public int updatePersonal(User user) {        return userMapper.updatePj(user);    }    @Override    public List<User> findByIds(Long[] ids) {        if (ids.length > 0) {            return userMapper.findByIds(ids);        }        return new ArrayList();    }}